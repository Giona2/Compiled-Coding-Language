The `Tokenizer` takes the list generated by the [Optimizer](modules/optimizer.md). It will then create a token "flowchart" that represents the computer instructions the final assembly file must take to excecute  

# Tokenization
___
**For this subheader, we will use the following example content:**  
```rust
vec!["int", "x", "=", "1", ";", "int", "y", "=", "2", ";", "int", "result", "=", "x", "+", "y", ";",]
```
___

The `Tokenizer` will iterate through each word. If it detects a type name, for example, it will retrieve the name, type (obviously), and what it's assigned to  
*at the moment, this is pretty much all the compiler can do*  
  
Using the example above, the compiler would parse it accordingly...
```
"int", "x", "=", "1", ";",
  │     │         ╰───────────────────────────────────────────╮
  │     ╰──────────────────────────────────────╮              │
  Create an integer declaration with the name "x" assigned to 1

"int", "y", "=", "2", ";", 
  │     │         ╰───────────────────────────────────────────╮
  │     ╰──────────────────────────────────────╮              │
  Create an integer declaration with the name "x" assigned to 2

"int", "result", "=", "x", "+", "y", ";",
  │       │            │    │
  │       │            │    ╰─────────────────────────────────────────────────────────────────────────────╮
  │       │            ╰──────────────────────────────────────────────────────────╮                       │
  │       ╰──────────────────────────────────────╮                                │                       │
  Create an integer declaration with the name "result" assigned to <the value in "x"> plus <the value in "y">
```
These parsed statements will then become consecutive tokens  
*See [Memory Management](modules/tokenizer#memory-management) for information on the `location` attribute*
```
╭──────────────────────────────────╮    ╭───────────────────────────────────╮  
│ Declaration                      │    │ Declaration                       │  
│ name: x                          │    │ name: y                           │  
│ location: {first slot in memory} │ -> │ location: {second slot in memory} │
│ data type: Integer               │    │ data type: Integer                │  
│ value: Integer(CONST(1))         │    │ value: Integer(CONST(2))          │     
╰──────────────────────────────────╯    ╰───────────────────────────────────╯  
                                                            \/
                                        ╭────────────────────────────────────────╮
                                        │ Declaration                            │
                                        │ name: result                           │
                                        │ location: {third slot in memory}       │
                                        │ data type: Integer                     │
                                        │ value: Integer(ADD(VAR("x")), VAR("y"))│       
                                        ╰────────────────────────────────────────╯
```

# Memory Management
To keep track of integral components like memory, these components each have a `struct` representation.  
Take memory for example. To keep track of variables, where they're stored, and what name they're assigned to in the script, the compiler has a `StackMemory` struct that tracks all these attributes  
  
When a new variable is initialized...
```
╭────────────────────────────────────╮
│ Declaration                        │
│ name: x                            │
│ location: {unknown slot in memory} │
│ data type: Integer                 │
│ value: Integer(CONST(1))           │
╰────────────────────────────────────╯
```
the `Tokenizer` will call `StackMemory` and tell it to add a variable.  
`StackMemory` indexes the variables as slots with a fixed size. It will search the slots and look for an empty one, then replace it with the new variable  
  
*Since `StackMemory`'s only function is to keep track of where new variables need to be placed in memory, the actual values do not need to be stored in this memory representation*
___
The visual representation would look something like...
```custom
[(), (), ...] -> declare x -> [StackVariable{name: "x", data_type: Integer}, (), ...]
```
___
  
The `Declaration` token will then ask `StackMemory` to find that variable it just created and give back the index/where it's stored in memory
___
The final declaration would become...
```
╭──────────────────────────────────╮
│ Declaration                      │
│ name: x                          │
│ location: {first slot in memory} │
│ data type: Integer               │
│ value: Integer(CONST(1))         │
╰──────────────────────────────────╯
```
___
