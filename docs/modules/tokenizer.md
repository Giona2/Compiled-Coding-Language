The `Tokenizer` takes the list generated by the [Optimizer](modules/optimizer.md). It will then create a token "flowchart" that represents the computer instructions the final assembly file must take to excecute  

# Tokenization
___
**For this subheader, we will use the following example content:**  
```rust
vec!["int", "x", "=", "1", ";", "int", "y", "=", "2", ";", "int", "result", "=", "x", "+", "y", ";",]
```
___

The `Tokenizer` will iterate through each word. If it detects a type name, for example, it will retrieve the name, type (obviously), and what it's assigned to. (at the moment, this is pretty much all the compiler can do)  
___
Using the example above, the compiler would parse it accordingly...
```
"int", "x", "=", "1", ";",
  │     │         ╰───────────────────────────────────────────╮
  │     ╰──────────────────────────────────────╮              │
  Create an integer declaration with the name "x" assigned to 1

"int", "y", "=", "2", ";", 
  │     │         ╰───────────────────────────────────────────╮
  │     ╰──────────────────────────────────────╮              │
  Create an integer declaration with the name "x" assigned to 1

"int", "result", "=", "x", "+", "y", ";",
  │       │            │    │
  │       │            │    ╰─────────────────────────────────────────────────────────────────────────────╮
  │       │            ╰──────────────────────────────────────────────────────────╮                       │
  │       ╰──────────────────────────────────────╮                                │                       │
  Create an integer declaration with the name "result" assigned to <the value in "x"> plus <the value in "y">
```
___
These parsed statements will then become consecutive tokens
___
```
╭──────────────────────────────────╮    ╭───────────────────────────────────╮  
│ Declaration                      │    │ Declaration                       │  
│ name: x                          │    │ name: y                           │  
│ location: {first slot in memory} │ -> │ location: {second slot in memory} │
│ data type: Integer               │    │ data type: Integer                │  
│ value: Integer(CONST(1))         │    │ value: Integer(CONST(2))          │     
╰──────────────────────────────────╯    ╰───────────────────────────────────╯  
                                                            \/
                                        ╭────────────────────────────────────────╮
                                        │ Declaration                            │
                                        │ name: result                           │
                                        │ location: {third slot in memory}       │
                                        │ data type: Integer                     │
                                        │ value: Integer(ADD(VAR("x")), VAR("y"))│       
                                        ╰────────────────────────────────────────╯
```

# Memory Management and Computer Component Representation
To keep track of integral components like memory, these components each have a `struct` that represents 
